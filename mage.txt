<<<<<<< HEAD
WEB服务及http协议

常见请求方法：
GET：获取服务器资源到本地的
POST：从本地把资源写入到服务器的
HEAD：首部
PUT：从远端服务器下载文件到本地的
DELETE：从远端服务器删除文件的
TRACE
OPTIONS
CONNECTION

SMTP:多用途互联网邮件扩展
	MIME协议
HTTP:使用Base64协议（引入MIME协议）

什么是动态网页？
动态网页是由客户端请求生成的，是非HTML格式的文件，是编程语言开发的脚本，脚本接收客户端参数后在服务器运行一次，并相对应的生成一个HTML文件发送给请求的客户端

web服务器处理客户端的动态网页请求时，不是web服务器生成html文件，而web服务器通过协议去调用相对应的脚本解释器去，解释器执行并生成html文件，并返回给web服务器发送给客户端。
动态网页：包含静态内容（图片等，不需要运行解释器）和动态内容（只有动态内容才需要运行解释器生成html）

阻塞：一直等待
非阻塞：就是轮循
无论是阻塞还是非阻塞都会接收客户端的请求，我们称阻塞或非阻塞在等待客户端请求时为监听

数据包
IP协议：源IP,目标IP
TCP协议：源端口，目标端口
HTTP首部：GET /2.html(什么方法，URL),Host: www.magedu.com(虚拟主机)
HTTP报文：请求报文，响应报文
请求报文语法：
-------------------------------
<method><request_URL><version>
<headers>
			
<entity-body> 
-------------------------------
<method>：请求的方法
<request_URL>:请求URL
<version>：http版本，http/1.0
<headers>：什么格式，什么类型的web对象
<entity-body>：报文主体
响应报文：
-------------------------------
<version><status><reason-phrase>
<headers>
			
<entity-body> 
-------------------------------
<version>：http版本，http/1.0
<status>:状态代码：1xx(纯信息)，2xx(成功类的信息，200),3xx(重定向类的信息，301，302，304),4xx(客户端错误类信息，404),5xx(服务器端错误类信息，501)
<reason-phrase>：进一步解释status的意义的
<headers>：什么格式，什么类型的web对象
<entity-body>：报文主体

请求报文例子：
GET / HTTP/1.1  #GET方式，默认主页
Host: www.magedu.com  #首部，名称及其值
Connection: keep-alive   #首部，名称及其值


响应报文例子：
HTTP/1.1 200 OK
X-Powered-By: PHP/5.2.17
Vary: Accept-Encoding,Cookie,User-Agent
Cache-Control: max-age=3,must-revalidata
Cotent-Encoding: gzip
Content-Length: 6931

原生态的web服务器主要操作（不会操作动态内容的）：
1.建立连接――接受或拒绝客户端连接请求
2.接收请求――通过网络读取HTTP请求报文
3.处理请求――解析请求报文并做出相应的动作
4.访问资源――访问请求报文中相关的资源
5.构建响应――使用正确的首部生成HTTP响应报文
6.发送响应――向客户端发送生成的响应报文
7.记录日志――当已经完成的http事务记录进日志文件

一个页面：10image,3css,5html,总共有18个资源
一个页面18个资源18个请求
http每个请求都是tcp协议的，三次握手，四次分手（说明了服务器压力很大，所以缓存是很有用的）

http/1.1：
增强了缓存的功能
长连接（减少三次握手的机会）:空闲超时，连接次数

四种模型：
1.单进程 2.多进程 3.单进程多请求 4.多进程多请求（最先进）
httpd,MPM模型:prefork,work,event

Client:IE,Firefox,Chrome,Opera,Safari
Server:Apache-httpd,IIS,nginx,lighttpd,thttpd
应用程序服务器（是web服务器也是解释器）：IIS,Tomcat(apache,JSP,开源),Websphere(IBM,解析JSP，不开源)，Weblogic(Oracle,解析JSP，不开源),JBoss(RedHat,实际是Tomcat,只是包装了)

全球web服务器统计（每半年统计一次）：https://www.netcraft.com/ 



------------httpd
NCSA,httpd――解散研发人员――研发人员不想httpd默落――通过互联网进行httpd的补丁和更新并发布新的版本――就被称为A Pactchy Server(充满补丁的服务，简称Apache)
开源界两个著名的基金会：
FSF:GNU,GPL
ASF:Apache Software Foundation

httpd特性：
1.事先创建空闲进程
2.按需维持适当的进程
3.模块设计，核心比较小，各种功能通过模块添加（包括php），支持运行时配置，支持单独编译模块
4.支持多种方式虚拟主机配置

HTTP/1.1比HTTP/1.0增加了缓存功能和长连接功能

支持https协议（mod_ssl）
支持用户认证
支持基于IP或主机名的ACL
支持每个目录的访问控制（默认站点可以不用认证访问，其他特定目录需要认证访问）
支持URL重写：/image/a.jpg转到/jack/image.abc.jpg。只是服务端重写，客户端无感知。

httpd:
/usr/sbin/httpd(MPM:prefork)#默认工作的模式
/etc/httpd #工作目录
/etc/httpd/conf #配置文件目录，主配置文件/etc/httpd/conf/httpd.conf
/etc/httpd/conf.d/*.conf  #主配置文件include进来的
/etc/httpd/modules #模块目录，是一个链接目录
/etc/httpd/logs --> /var/log/httpd #日志目录，有访问日志和错误日志两种
/var/www/html #静态网页目录
/var/www/cgi-bin #动态网页目录

perl #脚本语言，通过插件也可以写动态网页了。
python #脚本语言，通过插件现在也可以写动态网页了，
java #通过servlet插件也可以制作动态网页，而且直接嵌入到html中，不用手动编译，servlet直接帮我们编译运行了，现在比较流行
php #天生就是为动态网页而生的

假如同时有500个用户访问，每个用户访问10个动态资源，总共有多少进程？
500个web访问进程+500*10=5000个动态进程==5500个进程

一台web服务器有一个master process和多个work process进程，work进程是处理客户端web请求进程的，当有动态请求时，work进程把动态请求发送给应用程序服务器（解释器）运行[通过fastcgi协议通信，web服务器和应用程序服务器通过端口或套接字来联系的]，这时应用程序服务器work process接收到后进程处理并返还html文件给web进程，web进程在发送响应给客户端。注：应用程序服务器的master process是处理自己的子进程work process的

http安装:
yum install -y httpd
cd /etc/httpd/conf ; grep "Section" httpd.conf
httpd有三个主配置段：1.全部环境，2.主服务配置，3.虚拟主机
vim httpd.conf;配置文件中有#号的都为注释,#号后面没有空格的都为指令，指令后面对应的为值
指令不区别大小写，value区分大小写
具体指令说明可以访问官网：httpd.apache.org查看帮助手册。也可以在系统中安装手册:yum install -y httpd-manual;重启httpd服务即可访问http://localhost/manual
指令说明：
ServerToken OS #在错误页显示错误信息

=======
1、WEB服务及http协议

常见请求方法：
GET：获取服务器资源到本地的
POST：从本地把资源写入到服务器的
HEAD：首部
PUT：从远端服务器下载文件到本地的
DELETE：从远端服务器删除文件的
TRACE
OPTIONS
CONNECTION

SMTP:多用途互联网邮件扩展
	MIME协议
HTTP:使用Base64协议（引入MIME协议）

什么是动态网页？
动态网页是由客户端请求生成的，是非HTML格式的文件，是编程语言开发的脚本，脚本接收客户端参数后在服务器运行一次，并相对应的生成一个HTML文件发送给请求的客户端

web服务器处理客户端的动态网页请求时，不是web服务器生成html文件，而web服务器通过协议去调用相对应的脚本解释器去，解释器执行并生成html文件，并返回给web服务器发送给客户端。
动态网页：包含静态内容（图片等，不需要运行解释器）和动态内容（只有动态内容才需要运行解释器生成html）

阻塞：一直等待
非阻塞：就是轮循
无论是阻塞还是非阻塞都会接收客户端的请求，我们称阻塞或非阻塞在等待客户端请求时为监听

数据包
IP协议：源IP,目标IP
TCP协议：源端口，目标端口
HTTP首部：GET /2.html(什么方法，URL),Host: www.magedu.com(虚拟主机)
HTTP报文：请求报文，响应报文
请求报文语法：
-------------------------------
<method><request_URL><version>
<headers>
			
<entity-body> 
-------------------------------
<method>：请求的方法
<request_URL>:请求URL
<version>：http版本，http/1.0
<headers>：什么格式，什么类型的web对象
<entity-body>：报文主体
响应报文：
-------------------------------
<version><status><reason-phrase>
<headers>
			
<entity-body> 
-------------------------------
<version>：http版本，http/1.0
<status>:状态代码：1xx(纯信息)，2xx(成功类的信息，200),3xx(重定向类的信息，301，302，304),4xx(客户端错误类信息，404),5xx(服务器端错误类信息，501)
<reason-phrase>：进一步解释status的意义的
<headers>：什么格式，什么类型的web对象
<entity-body>：报文主体

请求报文例子：
GET / HTTP/1.1  #GET方式，默认主页
Host: www.magedu.com  #首部，名称及其值
Connection: keep-alive   #首部，名称及其值


响应报文例子：
HTTP/1.1 200 OK
X-Powered-By: PHP/5.2.17
Vary: Accept-Encoding,Cookie,User-Agent
Cache-Control: max-age=3,must-revalidata
Cotent-Encoding: gzip
Content-Length: 6931

原生态的web服务器主要操作（不会操作动态内容的）：
1.建立连接――接受或拒绝客户端连接请求
2.接收请求――通过网络读取HTTP请求报文
3.处理请求――解析请求报文并做出相应的动作
4.访问资源――访问请求报文中相关的资源
5.构建响应――使用正确的首部生成HTTP响应报文
6.发送响应――向客户端发送生成的响应报文
7.记录日志――当已经完成的http事务记录进日志文件

一个页面：10image,3css,5html,总共有18个资源
一个页面18个资源18个请求
http每个请求都是tcp协议的，三次握手，四次分手（说明了服务器压力很大，所以缓存是很有用的）

http/1.1：
增强了缓存的功能
长连接（减少三次握手的机会）:空闲超时，连接次数

四种模型：
1.单进程 2.多进程 3.单进程多请求 4.多进程多请求（最先进）
httpd,MPM模型:prefork,work,event

Client:IE,Firefox,Chrome,Opera,Safari
Server:Apache-httpd,IIS,nginx,lighttpd,thttpd
应用程序服务器（是web服务器也是解释器）：IIS,Tomcat(apache,JSP,开源),Websphere(IBM,解析JSP，不开源)，Weblogic(Oracle,解析JSP，不开源),JBoss(RedHat,实际是Tomcat,只是包装了)

全球web服务器统计（每半年统计一次）：https://www.netcraft.com/ 



二、------------httpd
NCSA,httpd――解散研发人员――研发人员不想httpd默落――通过互联网进行httpd的补丁和更新并发布新的版本――就被称为A Pactchy Server(充满补丁的服务，简称Apache)
开源界两个著名的基金会：
FSF:GNU,GPL
ASF:Apache Software Foundation

httpd特性：
1.事先创建空闲进程
2.按需维持适当的进程
3.模块设计，核心比较小，各种功能通过模块添加（包括php），支持运行时配置，支持单独编译模块
4.支持多种方式虚拟主机配置

HTTP/1.1比HTTP/1.0增加了缓存功能和长连接功能

支持https协议（mod_ssl）
支持用户认证
支持基于IP或主机名的ACL
支持每个目录的访问控制（默认站点可以不用认证访问，其他特定目录需要认证访问）
支持URL重写：/image/a.jpg转到/jack/image.abc.jpg。只是服务端重写，客户端无感知。

httpd:
/usr/sbin/httpd(MPM:prefork)#默认工作的模式
/etc/httpd #工作目录
/etc/httpd/conf #配置文件目录，主配置文件/etc/httpd/conf/httpd.conf
/etc/httpd/conf.d/*.conf  #主配置文件include进来的
/etc/httpd/modules #模块目录，是一个链接目录
/etc/httpd/logs --> /var/log/httpd #日志目录，有访问日志和错误日志两种
/var/www/html #静态网页目录
/var/www/cgi-bin #动态网页目录

perl #脚本语言，通过插件也可以写动态网页了。
python #脚本语言，通过插件现在也可以写动态网页了，
java #通过servlet插件也可以制作动态网页，而且直接嵌入到html中，不用手动编译，servlet直接帮我们编译运行了，现在比较流行
php #天生就是为动态网页而生的

假如同时有500个用户访问，每个用户访问10个动态资源，总共有多少进程？
500个web访问进程+500*10=5000个动态进程==5500个进程

一台web服务器有一个master process和多个work process进程，work进程是处理客户端web请求进程的，当有动态请求时，work进程把动态请求发送给应用程序服务器（解释器）运行[通过fastcgi协议通信，web服务器和应用程序服务器通过端口或套接字来联系的]，这时应用程序服务器work process接收到后进程处理并返还html文件给web进程，web进程在发送响应给客户端。注：应用程序服务器的master process是处理自己的子进程work process的

http安装及属性配置:
yum install -y httpd
cd /etc/httpd/conf ; grep "Section" httpd.conf
httpd有三个主配置段：1.全部环境，2.主服务配置，3.虚拟主机
vim httpd.conf;配置文件中有#号的都为注释,#号后面没有空格的都为指令，指令后面对应的为值
指令不区别大小写，value区分大小写
具体指令说明可以访问官网：httpd.apache.org查看帮助手册。也可以在系统中安装手册:yum install -y httpd-manual;重启httpd服务即可访问http://localhost/manual
属性配置：
ServerToken OS #在错误页显示错误信息
ServerRoot "/etc/httpd" #httpd服务的根目录
pidfile run/httpd.pid #pid目录
timeout 120 #tcp超时时间
KeepAlive off #是否打开长连接
maxkeepaliverequests 100 #长连接数最大请求数据，无限制可设为0
keepalivetimeout 15 #长连接时间断开时长，比较繁忙的服务器，可以设低点，比如5秒钟，使用ab命令去测试时间，或者使用loadRunner(HP公司的),loadRunner接近于真实环境来测试
<IfModule prefork.c> #prefork模型
StartServers       8  #prefork刚开始启动的进程数
MinSpareServers    5 #prefork最小空闲进程数
MaxSpareServers   20 #prefork最大空闲进程数
ServerLimit      256  #限制客户端最大连接数据，如果更改必须重启httpd服务（清理所有进程重新连接）
MaxClients       256 #客户端最大连接数，要想改大，先要改ServerLimit项后才能改
MaxRequestsPerChild  4000  #每一个进程最多响应4000个请求，超过kill掉重新生成
</IfModule>
<IfModule worker.c> #worker模型
StartServers         4  #worker刚开始启动的进程数
MaxClients         300  #最大客户端连接数
MinSpareThreads     25 #最小空闲线程，以所有线程为基数的
MaxSpareThreads     75 #最大空闲线程
ThreadsPerChild     25 #每一个进程生成25个子线程
MaxRequestsPerChild  0 #每一个进程最大响应多少请求，由于worker模式是线程响应的，所以这里为0，不做响应
</IfModule>
Listen 80 #监听本地主机所有端口，可以监听多个端口，多加几次Listen 8080参数即可
LoadModule foo_module modules/mod_foo.so #装载模块：模块名称：模块路径（相对路径，以ServerRoot为根的）
Include conf.d/*.conf  #包含目录下的*.conf文件
User apache  #work进程需要以普通用户运行，在这设置
Group apache
ServerAdmin root@localhost #站点管理员邮件地址，用来给管理员发邮件时用的地址
#ServerName www.example.com:80 #虚拟主机名，如果没有设置则会用本地主机IP反解的域名来使用主机名，一般localhost
DocumentRoot "/var/www/html" #网站根目录，
<Directory "/var/www/html"> #对网站根目录进行权限设置
 Options Indexes FollowSymLinks #Options定义对应目录下文件的访问属性的。Indexes把文件列出来，只有在当文件下载时用的，其他时候不要开启。Indexex(允许索引目录，不安全的),None（不任何支持选项），Includes(允许执行服务端包含（SSI），不安全的),FollowFSynLinks(允许使用符号链接,影响性能)，execCGI(允许运行CGI脚本)，All(支持所有选项)
 AllowOverride None #允许覆盖,是指定Order和Allow选项的
Order allow,deny #order意为顺序，设置先允许后拒绝的。只要没有被明确允许的都会被拒绝访问
Allow from all #允许从所有地方访问
地址的表示方式：1.ip 2.network/netmask 3.hostname 4.domainname 5.partial IP:172.16
 AllowOverride AuthConfig  #设置认证后的用户才能访问，第一次用htpasswd -c -m /etc/httpd/conf/htpasswd hadoop命令来创建hadoop用户的，-c意为第一次新建，如果第二次建用户，则不需要加-c,例：htpasswd -m /etc/httpd/conf/htpasswd tom 。-m意为md5加密,-D为删除用户
 AuthType Basic #认证类型为basic，有其他认证类型digest
 AuthName "Restrocted Sote...." #显示认证时的提示信息
 AuthUserFile "/etc/httpd/conf/htpasswd" #用户认证的帐号和密码文件路径
AuthGroupFile "/etc/httpd/conf/htgruop" #用户组的文件路径，组文件格式是：myusers: hadoop tom
 Require Valid-user #设置请求的户为所有有效的用户，也可以指定某个用户或某个组
 Require user hadoop #只允许hadoop用户访问
 Requier group myusers #只允许myusers这个组能访问
 </Directory>
<IfModule mod_userdir.c>
#UserDir disabled #是否允许用户在自己的家目录下创建网页（个人页面），例：http://192.168.1.233/~hadoop/
 UserDir public_html #只允许用户家目录下特定的public_html目录能创建网页，这个用户为linux用户，例如/home/hadoop/public_html/index.html && chmod o+x /home/www && http://192.168.1.233/~hadoop即可访问个人站点。须先重启服务
#<Directory /home/*/public_html> #定义用户家目录下特定目录的权限
#    AllowOverride FileInfo AuthConfig Limit
#    Options MultiViews Indexes SymLinksIfOwnerMatch IncludesNoExec
#    <Limit GET POST OPTIONS> #只限定GET POST OPTIONS三种方法
#        Order allow,deny 
#        Allow from all  #允许所有
#    </Limit>
#    <LimitExcept GET POST OPTIONS> #只限定除开GET POST OPTIONS外的方法
#        Order deny,allow
#        Deny from all  #拒绝所有
#    </LimitExcept>
#</Directory>
</IfModule>
DirectoryIndex index.html index.html.var #目录索引，就是主页文件，自左向右匹配，如果有权限访问而站点下没有这些主页，就会把目录给这个权限用户
AccessFileName .htaccess  #.htaccess是在站点下每个目录下的访问控制文件，从而达到每个目录权限控制，这个东西让apache的运行效率极低。生产环境是是禁用的
<Files ~ "^\.ht"> #模式匹配，以.ht开头的
  Order allow,deny  
  Deny from all #拒绝所有 
  Satisfy All
</Files>
TypesConfig /etc/mime.types #让http协议支持多媒体非二进制类型的文件，里面记录了支持的类型
DefaultType text/plain #默认类型是文本下的纯文本信息
<IfModule mod_mime_magic.c> #如果mod_mime_magic.c模块存在
 # MIMEMagicFile /usr/share/magic.mime
  MIMEMagicFile conf/magic  #就使用conf/magic信息
</IfModule>
HostnameLookups Off #是否让日志记录主机名而不是记录ip，设成主机名容易浪费主机资源
ErrorLog logs/error_log #定义错误日志路径
LogLevel warn #日志级别为warn
LogFormat "%h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-Agent}i\"" combined #定义日志格式，并给日志模式起个名字，combined为混合模式[%h远程主机、%l远端主机登录名称（一般为-）、%u 登录网站用户（没登录为-）、%t收到请求的时候、（\反斜号转义）%r第一行请求（为方法，URL，版本号）、%>s最后一个请求的状态码、%b响应报文的大小、%{Referer}i表示你从哪个页面来的、%{User-Agent}i记录用户浏览器]
 LogFormat "%h %l %u %t \"%r\" %>s %b" common #通用模式
LogFormat "%{Referer}i -> %U" referer #记录访问地址来源
LogFormat "%{User-agent}i" agent #只记录浏览器类型
CustomLog logs/access_log combined #定义日志类型为combined，通过访问日志来判断页面访问量（PV（page view）,pv按每天统计，按照每个页面来统计不能按照一个资源来访问），判断客户访问量（UV（user view），uv按独立IP访问量）
Alias /icons/ "/www/icons/" #别名，在站点下创建一个别名/icons，访问时实际内容指向/www/icons/下


[root@a019736cb441 /]#grep 'Section' /etc/httpd/conf/httpd.conf
### Section 1: Global Environment  #全局环境
### Section 2: 'Main' server configuration  #主Server段，只有一个web服务器不提供虚拟主机
### Section 3: Virtual Hosts #虚拟主机，禁用中心主机，有多台主机
httpd -t #测试配置文件语法
elinks http://192.168.1.233 #-dump参数代表不使用交换式，登录后就退出。-source显示html格式源码并退出
-----多处理模块(MPM)：
mpm_winnt（windows专用的）
worker（一个请求用一个线程响应，服务器启动多个进程，每个进程生成多个线程）
prefork(一个请求用一个进程响应)（httpd2.2默认）
event（一个进程处理多个请求，httpd2.4默认）,最强大的机制模型，nginx就是这种机制模型
切换httpd MPM程序：
注：如果在安装httpd时MPM模块编译了就有，没有就没有了
[root@salt-server /git/job]# httpd -l #查看编译的模块
Compiled in modules:
  core.c
  mod_so.c
  http_core.c
[root@a019736cb441 conf]#httpd -M  #httpd所有支持额外装载的模块
httpd: Could not reliably determine the server's fully qualified domain name, using 172.17.0.3 for ServerName
Loaded Modules:
 core_module (static)
 mpm_prefork_module (static)
 http_module (static)
 so_module (static)
 auth_basic_module (shared)

rpm -ql httpd | grep bin #可查看httpd的执行命令
[root@salt-server /git/job]# vim /etc/sysconfig/httpd 
"HTTPD"=/usr/sbin/httpd.worker #这里可以选择MPM模型，然后启动脚本会从这里读取从而启动不同进程，默认是prefork进程

四、httpd虚拟主机：
apache服务主机：
中心主机：不使用虚拟主机的主机
虚拟主机：服务于多个不同的站点
两个主机不能同时使用。
虚拟主机：
   基于IP: ip1:80,ip2:80
   基于端口：ip:80,ip:8080
   基于域名：ip:80，ip和端口相同，主机名不同（常用）。
apache2.2用NameVirtualHost启用
apache2.4想用什么类型虚拟主机就用哪种方式定义即可
虚拟主机之间不同配置处：
-------------
DocumentRoot /www/a.org/
ServerName
ServerAlias  #虚拟主机别名，可以多个
<Directory "/www/a.org/"> #基于目录的访问权限
	Options
	AllowOverride
</Directory>
Alias #别名不同
ErrorLog   #错误日志路径及格式
CustomLog  #访问日志路径及格式
<Location "/images"> #定义URL各个目录使用的权限，比如只允许使用GET方法等等

</Location>
ScriptAlias #脚本别名，允许执行CGI的目录（CGI通用网关接口协议）
-------------
虚拟主机的定义：（使用虚拟主机的时候必须先取消中心主机，注释DocumentRoot即可）
<VirtualHost www.jack.com>

</VirtualHost>
vim /etc/httpd/conf.d/virtual.conf
基于IP主机定义：
注释httpd.conf文件中DocumentRoot中心主机
<VirtualHost 172.17.0.3:80 >
        ServerName www.jack.com
        DocumentRoot "/www/magedu.com"
</VirtualHost>
<VirtualHost 172.17.0.2:80 >
        ServerName www.jack2.com
        DocumentRoot "/www/magedu2.com"
</VirtualHost>
用httpd -t 检查语法 

基于端口主机定义：
<VirtualHost 172.17.0.2:80 >
        ServerName www.jack2.com
        DocumentRoot "/www/magedu2.com"
</VirtualHost>
<VirtualHost 172.17.0.2:8080 >
        ServerName port.jack.com
        DocumentRoot "/www/magedu2.com"
</VirtualHost>
vim /etc/httpd/conf/httpd.conf添加listen8080端口。多监听端口

基于域名主机定义：
[root@a019736cb441 conf.d]#cat virtual.conf 
NameVirtualHost 172.17.0.2:80
<VirtualHost 172.17.0.2:80>
        ServerName sec.jack.com
        DocumentRoot "/www/magedu2.com/"
        CustomLog /var/www/httpd/sec.jack.com/access_log combined  #设置虚拟主机各自目录
       <Directory "/www/magedu2.com"> #设置这个主机目录不允许172.168.0.3访问
	Options none
	AllowOverride none
	Order deny,allow
	Deny from 172.168.0.3
       </Directory>
</VirtualHost>
<VirtualHost 172.17.0.2:80>
        ServerName domain.jack.com
        DocumentRoot "/www/magedu3.com/"
        CustomLog /var/www/httpd/domain.jack.com/access_log combined
        <Directory "/www/magedu3.com">
                Options none
                AllowOverride authconfig
                AuthType Basic
                AuthName "Restrocted Sote..."
                AuthUserFile "/etc/httpd/config/htpasswd"
                Require Valid-user #设置有登录认证
        </Directory>
</VirtualHost>

<VirtualHost 172.17.0.2:80>  
        ServerName _default_  #默认虚拟主机，必须写在虚拟主机的第一个
        DocumentRoot "/www/default/"
</VirtualHost>

-------------
客户端动态：从服务器把脚本复制到客户端本地运行，不安全（例如黑客写个格式化硬盘脚本），适用性不强
服务端动态：基于CGI协议技术调用解释器运行脚本返回给apache（解释器：bash,c,php,python,java等）
MVC:一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码
directory定义的是本地目录的权限，location定义的是url权限
<Location /server-status>#URL是http://localhost/server-status
    SetHandler server-status #执行一个动作，调用某些文件的时候可以执行一些动作
    Order allow,deny
    Allow from all
</Location>

----------
五、基于openssl的https服务配置
客户端和服务端tcp三次握手之后就可以建立ssl会话了
客户端和服务端协商单项加密算法、对称加密算法、公钥加密算法，选择大家都支持的算法，每种算法都可以用得到，这些算法都要进行选择的，一旦选择完成了，双方才可以建立ssl会话，server端用协商的单项加密算法加密证书（公钥）发送给客户端，客户端用单项加密算法解密验证证书，验证完成后没有问题，就用服务端的公钥加密一个对称密钥发送给服务端，完成后，服务端就有了和客户端配对的对称密钥，然后客户端将请求页面发送给服务端，服务端就用对称密钥加密内容给客户端。
#证书：
服务端要找一个第三方证书机构颁发证书，客户端上要把第三方机构证书放到信任路径后才能信任服务器证书。我们这里没办法找第三方机构，我们现在自建一个证书机构CA，颁发的证书也叫自签名证书。
服务器和客户端使用证书流程：
服务器生成一对密钥--服务器把公钥发送给CA--CA给服务器发来的公钥签名并颁发证书发送给服务器--服务器配置服务器使用证书--并且在客户端发送请求的时候发送证书给客户端--客户端用保存在自己机器上的CA机构证书验证服务器发来的证书是否有效。
##ssl会话仅能支持ip地址不支持主机名，如果主机只有一个ip地址的话，有多个虚拟主机情况下，那么只能有一个虚拟主机能拿来使用ssl，其他虚拟主机不能使用ssl
如果apache要想使用https功能，那么apache要安装ssl模块，使用httpd -Ms来查看是否已经安装需要的模块
yum install mod_ssl -y  #基于rpm包安装mod_ssl
[root@a019736cb441 conf.d]#rpm -ql mod_ssl
/etc/httpd/conf.d/ssl.conf  #涉及新的端口（套接字），必须重启服务
/usr/lib64/httpd/modules/mod_ssl.so #安装的模块
/var/cache/mod_ssl #ssl的缓存目录
/var/cache/mod_ssl/scache.dir
/var/cache/mod_ssl/scache.pag
/var/cache/mod_ssl/scache.sem

制作CA，先生成私钥：（apache服务和CA在一台服务器）
cd /etc/pki/CA/ 
[root@a019736cb441 CA]#(umask 077;openssl genrsa -out private/cakey.pem 2048) #用openssl生成rsa类型的CA私钥，输出保存在/etc/pki/CA/private/cakey.pem，长度为2048，权限只允许root有，所以umask为077
[root@a019736cb441 CA]#ls private/ -l
total 4
-rw------- 1 root root 1679 Mar 21 10:30 cakey.pem
vim /etc/pki/tls/openssl.cnf #先把生成证书默认信息改成自己需的信息
-------------
[ req_distinguished_name ]
countryName                     = Country Name (2 letter code)
countryName_default             = CN #国家：中国
countryName_min                 = 2
countryName_max                 = 2

stateOrProvinceName             = State or Province Name (full name)
stateOrProvinceName_default     = Shanghai #省：上海

localityName                    = Locality Name (eg, city)
localityName_default            = Shanghai #位置：上海
0.organizationName              = Organization Name (eg, company)
0.organizationName_default      = Magedu #组织：Magedu

# we can do this but it is not needed normally :-)
#1.organizationName             = Second Organization Name (eg, company)
#1.organizationName_default     = World Wide Web Pty Ltd

organizationalUnitName          = Organizational Unit Name (eg, section)
#organizationalUnitName_default =
organizationalUnitName_default  = Tech #组织单元名称：Tech
-------------
生成自签名证书：
[root@a019736cb441 CA]#openssl req -new -x509 -key private/cakey.pem -out cacert.pem -days 3655 #给自己生成自签名证书，用做客户端用
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [CN]: #下面五条是刚刚设置的信息
State or Province Name (full name) [Shanghai]:
Locality Name (eg, city) [Shanghai]:
Organization Name (eg, company) [Magedu]:
Organizational Unit Name (eg, section) [Tech]:
Common Name (eg, your name or your server's hostname) []:ca.magedu.com #主机名设置，跟你的网站域名要一模一样，否则会有警告
Email Address []:admin@magedu.com #邮箱
[root@a019736cb441 CA]#ls
cacert.pem  certs  crl  newcerts  private
要把自己扮成私有CA，还需要改/etc/pki/tls/openssl.cnf的配置信息：
[root@a019736cb441 CA]#vim /etc/pki/tls/openssl.cnf
---------------
[ CA_default ]

dir             = /etc/pki/CA           # CA的工作目录
certs           = $dir/certs            # 生成的证书目录
crl_dir         = $dir/crl              # 吊销的证书目录
database        = $dir/index.txt        # 签的有哪些证书
new_certs_dir   = $dir/newcerts         # 新签的证书目录
certificate     = $dir/cacert.pem       # 自签名证书
serial          = $dir/serial           # 签到第几个，序列号
crlnumber       = $dir/crlnumber        # 
crl             = $dir/crl.pem          # 
private_key     = $dir/private/cakey.pem# 私钥
RANDFILE        = $dir/private/.rand    # 

x509_extensions = usr_cert              # 
---------------
[root@a019736cb441 CA]#touch index.txt #新建目录及文件使匹配CA设置
[root@a019736cb441 CA]#echo 01 > serial
[root@a019736cb441 CA]#ls
cacert.pem  certs  crl  index.txt  newcerts  private  serial
CA证书机构已经制作完成了，之后只需要服务器生成密钥，把自己的公钥通过申请发送给CA，CA颁发就可以完成证书的颁发了。
回到服务器：
[root@a019736cb441 ssl]#pwd
/etc/httpd/ssl #创建ssl目录，放置密钥对
[root@a019736cb441 ssl]#(umask 077;openssl genrsa 1024 > httpd.key) #生成私钥
Generating RSA private key, 1024 bit long modulus
.................................................++++++
....................++++++
e is 65537 (0x10001)
[root@a019736cb441 ssl]#openssl req -new -key httpd.key -out httpd.csr #生成证书申请请求文件，里面的地址组织信息一定要跟CA的地址组织信息一致，因为证书机构一般是你的所在地证书机构
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [CN]:
State or Province Name (full name) [Shanghai]:
Locality Name (eg, city) [Shanghai]:
Organization Name (eg, company) [Magedu]:
Organizational Unit Name (eg, section) [Tech]:
Common Name (eg, your name or your server's hostname) []:hallo.magedu.com  #你要申请证书的域名
Email Address []:hallo@magedu.com

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:  #密码可以不填
An optional company name []:
然后把服务器的证书申请请求文件发送给CA，可以通过scp来发送。
CA签署服务器的证书申请请求：
---------------
[root@a019736cb441 ssl]#openssl ca -in /etc/httpd/ssl/httpd.csr -out /etc/httpd/ssl/httpd.crt -days 3650 #ca签署证书申请请求
Using configuration from /etc/pki/tls/openssl.cnf
Check that the request matches the signature
Signature ok
Certificate Details:
        Serial Number: 1 (0x1)
        Validity
            Not Before: Mar 21 15:25:09 2019 GMT
            Not After : Mar 18 15:25:09 2029 GMT
        Subject:
            countryName               = CN
            stateOrProvinceName       = Shanghai
            organizationName          = Magedu
            organizationalUnitName    = Tech
            commonName                = hallo.magedu.com
            emailAddress              = hallo@magedu.com
        X509v3 extensions:
            X509v3 Basic Constraints:
                CA:FALSE
            Netscape Comment:
                OpenSSL Generated Certificate
            X509v3 Subject Key Identifier:
                A4:90:2F:0C:FB:1E:A5:6E:4D:CE:5F:22:91:16:74:CE:EA:C6:20:F3
            X509v3 Authority Key Identifier:
                keyid:69:FF:35:51:CD:92:AD:B8:82:DD:60:C8:4F:80:60:76:C2:18:11:C7

Certificate is to be certified until Mar 18 15:25:09 2029 GMT (3650 days)
Sign the certificate? [y/n]:y #同意签署


1 out of 1 certificate requests certified, commit? [y/n]y ##再次同意签署
Write out database with 1 new entries
Data Base Updated

---------------
[root@a019736cb441 ssl]#cat /etc/pki/CA/index.txt #在CA中查看可看到已经签署的证书
V       290318152509Z           01      unknown /C=CN/ST=Shanghai/O=Magedu/OU=Tech/CN=hallo.magedu.com/emailAddress=hallo@magedu.com
[root@a019736cb441 ssl]#cat /etc/pki/CA/serial
02 #之前为01，现在为02，增加了一个证书
注：其他无关的证书一定要清理掉。
配置服务器使用证书：








